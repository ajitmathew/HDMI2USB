C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 1   


C51 COMPILER V7.07, COMPILATION OF MODULE FW
OBJECT MODULE PLACED IN .\output\fw.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE fw.c BROWSE INCDIR(C:\Cypress\USB\CY3684_EZ-USB_FX2LP_DVK\1.0\Target\Inc;C:
                    -\Cypress\USB\CY3684_EZ-USB_FX2LP_DVK\1.0\uV2_4k\C51\INC) DEBUG OBJECTEXTEND PRINT(.\output\fw.lst) OBJECT(.\output\fw.ob
                    -j)

stmt level    source

   1          //-----------------------------------------------------------------------------
   2          //   File:      fw.c
   3          //   Contents:  Firmware frameworks task dispatcher and device request parser
   4          //
   5          // $Archive: /USB/Examples/FX2LP/bulkext/fw.c $
   6          // $Date: 3/23/05 2:53p $
   7          // $Revision: 8 $
   8          //
   9          //
  10          //-----------------------------------------------------------------------------
  11          // Copyright 2003, Cypress Semiconductor Corporation
  12          //-----------------------------------------------------------------------------
  13          #include "fx2.h"
  14          #include "fx2regs.h"
  15          //#include "syncdly.h"            // SYNCDELAY macro
  16          
  17          //-----------------------------------------------------------------------------
  18          // Constants
  19          //-----------------------------------------------------------------------------
  20          #define DELAY_COUNT   0x9248*8L  // Delay for 8 sec at 24Mhz, 4 sec at 48
  21          #define _IFREQ  24000            // IFCLK constant for Synchronization Delay
  22          #define _CFREQ  24000            // CLKOUT constant for Synchronization Delay
  23          //#define       _SCYCL  1
  24          
  25          
  26          //-----------------------------------------------------------------------------
  27          // Random Macros
  28          //-----------------------------------------------------------------------------
  29          #define   min(a,b) (((a)<(b))?(a):(b))
  30          #define   max(a,b) (((a)>(b))?(a):(b))
  31          
  32          #include "fx2sdly.h"
  33          //----------------------------------------------------------------------------
  34          //      UVC definations
  35          //----------------------------------------------------------------------------
  36          #define         UVC_SET_INTERFACE               0x21    // SET_Interface : UVC
  37          #define         UVC_GET_INTERFACE               0xA1    // GET_Interface : UVC
  38          
  39          #define         UVC_SET_ENDPOINT                0x22    // SET_ENDPOINT : UVC
  40          #define         UVC_GET_ENDPOINT                0xA2    // GET_ENDPOINT : UVC
  41          
  42          
  43          #define RC_UNDEFINED    0x00
  44          #define SET_CUR                 0x01
  45          #define SET_CUR_ALL     0x11
  46          #define GET_CUR                 0x81 // 1
  47          #define GET_MIN                 0x82 //
  48          #define GET_MAX                 0x83 // 2
  49          #define GET_RES                 0x84
  50          #define GET_LEN                 0x85
  51          #define GET_INFO                0x86
  52          #define GET_DEF                 0x87
  53          #define GET_CUR_ALL     0x91
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 2   

  54          #define GET_MIN_ALL     0x92
  55          #define GET_MAX_ALL     0x93
  56          #define GET_RES_ALL     0x94
  57          #define GET_DEF_ALL     0x97
  58          
  59          
  60          //-----------------------------------------------------------------------------
  61          // Global Variables
  62          //-----------------------------------------------------------------------------
  63          volatile  BOOL   GotSUD;
  64          BOOL      Rwuen;
  65          BOOL      Selfpwr;
  66          volatile BOOL   Sleep;                  // Sleep mode enable flag
  67          
  68          WORD   pDeviceDscr;   // Pointer to Device Descriptor; Descriptors may be moved
  69          WORD   pDeviceQualDscr;
  70          WORD   pHighSpeedConfigDscr;
  71          WORD   pFullSpeedConfigDscr;   
  72          WORD   pConfigDscr;
  73          WORD   pOtherConfigDscr;   
  74          WORD   pStringDscr;   
  75          WORD   pUserDscr;   
  76          WORD   pVSUserDscr;   
  77          
  78          BYTE valuesArray[48];
  79          
  80          //-----------------------------------------------------------------------------
  81          // Prototypes
  82          //-----------------------------------------------------------------------------
  83          void SetupCommand(void);
  84          //void TD_Init(void);
  85          //void TD_Poll(void);
  86          BOOL TD_Suspend(void);
  87          BOOL TD_Resume(void);
  88          
  89          BOOL DR_GetDescriptor(void);
  90          BOOL DR_SetConfiguration(void);
  91          BOOL DR_GetConfiguration(void);
  92          BOOL DR_SetInterface(void);
  93          BOOL DR_GetInterface(void);
  94          BOOL DR_GetStatus(void);
  95          BOOL DR_ClearFeature(void);
  96          BOOL DR_SetFeature(void);
  97          BOOL DR_VendorCmnd(void);
  98          
  99          // this table is used by the epcs macro 
 100          const char code  EPCS_Offset_Lookup_Table[] =
 101          {
 102             0,    // EP1OUT
 103             1,    // EP1IN
 104             2,    // EP2OUT
 105             2,    // EP2IN
 106             3,    // EP4OUT
 107             3,    // EP4IN
 108             4,    // EP6OUT
 109             4,    // EP6IN
 110             5,    // EP8OUT
 111             5,    // EP8IN
 112          };
 113          
 114          // macro for generating the address of an endpoint's control and status register (EPnCS)
 115          #define epcs(EP) (EPCS_Offset_Lookup_Table[(EP & 0x7E) | (EP > 128)] + 0xE6A1)
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 3   

 116          
 117          //-----------------------------------------------------------------------------
 118          // Code
 119          //-----------------------------------------------------------------------------
 120          // unsigned char code LEDSegTabel[] = 
 121          // {
 122              // 0x44, 0xf5, 0x1c, 0x94, 0xa5,
 123                  // 0x86, 0x06, 0xf4, 0x04, 0x84, 
 124                  // 0x24, 0x07, 0x4e, 0x15, 0x0e, 0x2e};
 125          #define SHRCLK 4
 126          #define LATCLK 5
 127          #define SDI    6
 128          // void CY_IOInit(void)
 129          // {
 130              // OEA = 0x0f;
 131                  // IOA = 0x0f;
 132          // }
 133          
 134          void DelayMs(void)
 135          {
 136   1         unsigned long t = 40000;
 137   1         while(t--);
 138   1      }
 139          /*
 140          void DispLeds(unsigned short value)
 141          {
 142              unsigned char Bitcnt = 16;
 143                  
 144                  IOE &= ~(1 << LATCLK);
 145                  for (Bitcnt = 0; Bitcnt < 16; Bitcnt++)
 146                  {
 147                      IOE &= ~(1 << SHRCLK);
 148                          (value&0x8000)?(IOE |= (1 << SDI)):(IOE &= ~(1 << SDI));
 149                          IOE |= (1 << SHRCLK);
 150                          value <<= 1;
 151                  }
 152                  IOE |= (1 << LATCLK);
 153          }
 154          */
 155          unsigned short xdata ExtMem[0x4000] _at_ 0x4000;
 156          void ExtMemTest(void)
 157          {
 158   1              unsigned short counter = 0;
 159   1      
 160   1          for (;counter < 0x4000; counter++)
 161   1              {
 162   2                  ExtMem[counter] = counter;
 163   2              }
 164   1              counter = 0;
 165   1              for (;counter < 0x4000; counter++)
 166   1              {
 167   2                      if (counter != ExtMem[counter])
 168   2                      {
 169   3                          while(1)
 170   3                              {
 171   4                                      IOB ^= 0XFF;
 172   4                                      DelayMs();
 173   4                              }
 174   3                      }
 175   2              }
 176   1      }
 177          //[YourCompany]%DeviceDesc%=CyLoad, USB\VID_04B4&PID_0084
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 4   

 178          // Task dispatcher
 179          void main(void)
 180          {
 181   1      //   DWORD   i;
 182   1      //   WORD   offset;
 183   1      //   DWORD   DevDescrLen;
 184   1         DWORD   j=0;
 185   1      //   WORD   IntDescrAddr;
 186   1      //   WORD   ExtDescrAddr;
 187   1      
 188   1      
 189   1      valuesArray[0] = 0; //db        00H
 190   1      valuesArray[1] = 0;// db        00H ;bmHint     
 191   1      
 192   1      valuesArray[2] = 1;// db        01H ;bFormatIndex
 193   1      valuesArray[3] = 1;// db        01H ;bFrameIndex
 194   1      
 195   1      valuesArray[4] = 0x2A;// db     2AH
 196   1      valuesArray[5] = 0x2c;// db     2CH
 197   1      valuesArray[6] = 0x0A;// db     0AH
 198   1      valuesArray[7] = 0;// db        00H; dwFrameInterval
 199   1      
 200   1      valuesArray[8] = 0;// db        00H 
 201   1      valuesArray[9] = 0;// db        00H ; wKeyFrameRate
 202   1      
 203   1      valuesArray[10] = 0;// db       00H
 204   1      valuesArray[11] = 0;// db       00H ; wPFrameRate
 205   1      
 206   1      valuesArray[12] = 0x3D;// db    01H
 207   1      valuesArray[13] = 0;// db       00H ; wCompQuality
 208   1      
 209   1      valuesArray[14] = 0;// db       16
 210   1      valuesArray[15] = 0;// db       00H ;wCompWindowSize
 211   1      
 212   1      valuesArray[16] = 0;// db       50
 213   1      valuesArray[17] = 0;// db       00H ;wDelay
 214   1      
 215   1      valuesArray[18] = 0;//0x80;// db        80H //00
 216   1      valuesArray[19] = 0x60;//0x94;// db     94H //60H
 217   1      valuesArray[20] = 0x09;//0;// db        00H  //09H
 218   1      valuesArray[21] = 0;// db       00H; //00 17  dwMaxVideoFrameBufferSize 4  Number  Use of this field has been de
             -precated.Specifies the maximum number of bytes for a video (or still image) frame the compressor will produce.  The 
 219   1      // ;dwMaxVideoFrameSize field of the Video Probe and Commit control  replaces this descriptor field. A val
             -ue for this field shall be chosen for  compatibility with host software that implements an 
 220   1      // ;earlier version of this specification.
 221   1      
 222   1      valuesArray[22] = 0x0;//0;// db 00H //f4
 223   1      valuesArray[23] = 0x0;//;// db  02H //0B ; 
 224   1      valuesArray[24] = 0;// db       00H
 225   1      valuesArray[25] = 0;// db       00H ;dwMaxPayloadTransferSize
 226   1      
 227   1      // // ; 2 DC 6C 00 48Mhz
 228   1      valuesArray[26] = 0;// db       00H
 229   1      valuesArray[27] = 0x6C;// db    6CH
 230   1      valuesArray[28] = 0xDC;// db    0DCH
 231   1      valuesArray[29] = 2;// db       02H ; dwClockFrequency
 232   1      
 233   1      valuesArray[30] = 0;// db 00H ; bmFramingInfo
 234   1      
 235   1      valuesArray[31] = 2;// db       2 ; bPreferedVersion
 236   1      valuesArray[32] = 0;// db       0 ; bMinVersion
 237   1      valuesArray[33] = 0;// db       0 ; bMaxVersion
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 5   

 238   1      valuesArray[34] = 1;// db       1; bUsage
 239   1      valuesArray[35] = 8;// db       8;bBitDepthLuma
 240   1      valuesArray[36] = 0;// db       0; bmSettings
 241   1      valuesArray[37] = 1;// db       1; bMaxNumberOfRefFramesPlus1
 242   1      valuesArray[38] = 0;// db       0;
 243   1      valuesArray[39] = 0;// db       0;bmRateControlModes
 244   1      
 245   1      valuesArray[40] = 0;// db       0
 246   1      valuesArray[41] = 0;// db       0
 247   1      valuesArray[42] = 0;// db       0
 248   1      valuesArray[43] = 0;// db       0
 249   1      valuesArray[44] = 0;// db       0
 250   1      valuesArray[45] = 0;// db       0
 251   1      valuesArray[46] = 0;// db       0
 252   1      valuesArray[47] = 0;// db       0; bmLayoutPerStream
 253   1      
 254   1      
 255   1      
 256   1         // Initialize Global States
 257   1         Sleep = FALSE;               // Disable sleep mode
 258   1         Rwuen = FALSE;               // Disable remote wakeup
 259   1         Selfpwr = FALSE;            // Disable self powered
 260   1         GotSUD = FALSE;               // Clear "Got setup data" flag
 261   1      
 262   1         
 263   1      
 264   1         //==========================================================
 265   1        // CPUCS = 0x10; // CLKSPD[1:0]=10, for 48MHz operation, output CLKOUT
 266   1        SYNCDELAY;
 267   1       FIFOPINPOLAR = 0x00;
 268   1      SYNCDELAY;
 269   1        // PINFLAGSAB = 0x08;                 // FLAGA - EP6FF
 270   1        PINFLAGSAB = 0x00;                    // FLAGA - EP6FF
 271   1        SYNCDELAY;
 272   1        // PINFLAGSCD = 0xE0;                 // FLAGD - EP2EF
 273   1        PINFLAGSCD = 0x00;                    // FLAGD - EP2EF
 274   1        SYNCDELAY;
 275   1        PORTACFG |= 0x80;
 276   1        SYNCDELAY;
 277   1        IFCONFIG = 0xE3; // for async? for sync?
 278   1      SYNCDELAY;
 279   1        // IFCLKSRC=1   , FIFOs executes on internal clk source 
 280   1        // xMHz=1       , 48MHz operation
 281   1        // IFCLKOE=1    ,Drive IFCLK pin signal at 48MHz
 282   1        // IFCLKPOL=0   , Don't invert IFCLK pin signal from internal clk
 283   1        // ASYNC=0      , master samples synchronous
 284   1        // GSTATE=0     , Don't drive GPIF states out on PORTE[2:0], debug WF
 285   1        // IFCFG[1:0]=11, FX2 in slave FIFO mode
 286   1      
 287   1      
 288   1        // Registers which require a synchronization delay, see section 15.14
 289   1        // FIFORESET        FIFOPINPOLAR
 290   1        // INPKTEND         OUTPKTEND
 291   1        // EPxBCH:L         REVCTL
 292   1        // GPIFTCB3         GPIFTCB2
 293   1        // GPIFTCB1         GPIFTCB0
 294   1        // EPxFIFOPFH:L     EPxAUTOINLENH:L
 295   1        // EPxFIFOCFG       EPxGPIFFLGSEL
 296   1        // PINFLAGSxx       EPxFIFOIRQ
 297   1        // EPxFIFOIE        GPIFIRQ
 298   1        // GPIFIE           GPIFADRH:L
 299   1        // UDMACRCH:L       EPxGPIFTRIG
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 6   

 300   1        // GPIFTRIG
 301   1        
 302   1        // Note: The pre-REVE EPxGPIFTCH/L register are affected, as well...
 303   1        //      ...these have been replaced by GPIFTC[B3:B0] registers
 304   1      
 305   1      
 306   1        
 307   1       
 308   1      
 309   1        // EP4 and EP8 are not used in this implementation...
 310   1                         
 311   1        EP2CFG = 0xA2;                //out 512 bytes, 2x, bulk
 312   1        SYNCDELAY;                    
 313   1        EP6CFG = 0xE2;                // in 512 bytes, 2x, bulk
 314   1        SYNCDELAY;              
 315   1        EP4CFG = 0xE2;                // in 512 bytes, 2x, bulk
 316   1        SYNCDELAY;                     
 317   1        EP8CFG = 0x02;                //clear valid bit
 318   1        SYNCDELAY;   
 319   1      
 320   1        SYNCDELAY;
 321   1        FIFORESET = 0x80;             // activate NAK-ALL to avoid race conditions
 322   1        SYNCDELAY;                    // see TRM section 15.14
 323   1        FIFORESET = 0x02;             // reset, FIFO 2
 324   1        SYNCDELAY;                    // 
 325   1        FIFORESET = 0x04;             // reset, FIFO 4
 326   1        SYNCDELAY;                    // 
 327   1        FIFORESET = 0x06;             // reset, FIFO 6
 328   1        SYNCDELAY;                    // 
 329   1        FIFORESET = 0x08;             // reset, FIFO 8
 330   1        SYNCDELAY;                    // 
 331   1        FIFORESET = 0x00;             // deactivate NAK-ALL
 332   1      
 333   1      
 334   1        // handle the case where we were already in AUTO mode...
 335   1        // ...for example: back to back firmware downloads...
 336   1        SYNCDELAY;                    // 
 337   1        EP2FIFOCFG = 0x00;            // AUTOOUT=0, WORDWIDE=1
 338   1        
 339   1        // core needs to see AUTOOUT=0 to AUTOOUT=1 switch to arm endp's
 340   1        
 341   1        SYNCDELAY;                    // 
 342   1        EP2FIFOCFG = 0x10;            // AUTOOUT=1, WORDWIDE=1
 343   1        
 344   1        SYNCDELAY;                    // 
 345   1        EP4FIFOCFG = 0x0C;            // AUTOIN=1, ZEROLENIN=1, WORDWIDE=1
 346   1          SYNCDELAY;  
 347   1        EP6FIFOCFG = 0x0C;            // AUTOIN=1, ZEROLENIN=1, WORDWIDE=1
 348   1      
 349   1        SYNCDELAY;
 350   1      
 351   1      
 352   1        
 353   1              EP2AUTOINLENH = 0x02; // EZ-USB automatically commits data in 512-byte chunks
 354   1              SYNCDELAY;
 355   1              EP2AUTOINLENL = 0x00;
 356   1              SYNCDELAY;
 357   1              
 358   1              EP4AUTOINLENH = 0x02; // EZ-USB automatically commits data in 512-byte chunks
 359   1              SYNCDELAY;
 360   1              EP4AUTOINLENL = 0x00;
 361   1              SYNCDELAY;
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 7   

 362   1              
 363   1              EP6AUTOINLENH = 0x02; // EZ-USB automatically commits data in 512-byte chunks
 364   1              SYNCDELAY;
 365   1              EP6AUTOINLENL = 0x00;
 366   1              SYNCDELAY;
 367   1              
 368   1              //==============================================================================
 369   1              // PORTACFG = 0x00; // 
 370   1              // SYNCDELAY;
 371   1      
 372   1              // OEA = 0xFF;
 373   1              // IOA = 0x00; 
 374   1              
 375   1              
 376   1              OED = 0xFF;
 377   1              IOD = 0xFF; 
 378   1         //==========================================================
 379   1      
 380   1         
 381   1         // Initialize user device
 382   1         // TD_Init();
 383   1              // CY_IOInit();
 384   1         // The following section of code is used to relocate the descriptor table. 
 385   1         // The frameworks uses SUDPTRH and SUDPTRL to automate the SETUP requests
 386   1         // for descriptors.  These registers only work with memory locations
 387   1         // in the EZ-USB internal RAM.  Therefore, if the descriptors are located
 388   1         // in external RAM, they must be copied to in internal RAM.  
 389   1         // The descriptor table is relocated by the frameworks ONLY if it is found 
 390   1         // to be located in external memory.
 391   1         pDeviceDscr = (WORD)&DeviceDscr;
 392   1         pDeviceQualDscr = (WORD)&DeviceQualDscr;
 393   1         pHighSpeedConfigDscr = (WORD)&HighSpeedConfigDscr;
 394   1         pFullSpeedConfigDscr = (WORD)&FullSpeedConfigDscr;
 395   1         pStringDscr = (WORD)&StringDscr;
 396   1         pUserDscr = (WORD)&UserDscr;
 397   1         //pVSUserDscr = (WORD) & VSUserDscr;
 398   1      
 399   1      
 400   1      
 401   1         // Is the descriptor table in external RAM (> 16Kbytes)?  If yes,
 402   1         // then relocate.
 403   1         // Note that this code only checks if the descriptors START in 
 404   1         // external RAM.  It will not work if the descriptor table spans
 405   1         // internal and external RAM.
 406   1      /*   if ((WORD)&DeviceDscr & 0xC000)
 407   1         {
 408   1            // first, relocate the descriptors
 409   1            IntDescrAddr = INTERNAL_DSCR_ADDR;
 410   1            ExtDescrAddr = (WORD)&DeviceDscr;
 411   1            DevDescrLen = (WORD)&UserDscr - (WORD)&DeviceDscr + 2;
 412   1            for (i = 0; i < DevDescrLen; i++)
 413   1               *((BYTE xdata *)IntDescrAddr+i) = *((BYTE xdata *)ExtDescrAddr+i);
 414   1      
 415   1            // update all of the descriptor pointers
 416   1            pDeviceDscr = IntDescrAddr;
 417   1            offset = (WORD)&DeviceDscr - INTERNAL_DSCR_ADDR;
 418   1            pDeviceQualDscr -= offset;
 419   1            pConfigDscr -= offset;
 420   1            pOtherConfigDscr -= offset;
 421   1            pHighSpeedConfigDscr -= offset;
 422   1            pFullSpeedConfigDscr -= offset;
 423   1            pStringDscr -= offset;
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 8   

 424   1         }
 425   1      */
 426   1         EZUSB_IRQ_ENABLE();            // Enable USB interrupt (INT2)
 427   1         EZUSB_ENABLE_RSMIRQ();            // Wake-up interrupt
 428   1      
 429   1         INTSETUP |= (bmAV2EN | bmAV4EN);     // Enable INT 2 & 4 autovectoring
 430   1      
 431   1         USBIE |= bmSUDAV | bmSUTOK | bmSUSP | bmURES | bmHSGRANT;   // Enable selected interrupts
 432   1         EA = 1;                  // Enable 8051 interrupts
 433   1      #ifndef NO_RENUM
 434   1         // Renumerate if necessary.  Do this by checking the renum bit.  If it
 435   1         // is already set, there is no need to renumerate.  The renum bit will
 436   1         // already be set if this firmware was loaded from an eeprom.
 437   1         if(!(USBCS & bmRENUM))
 438   1         {
 439   2             EZUSB_Discon(TRUE);   // renumerate
 440   2         }
 441   1      #endif
 442   1      
 443   1         // unconditionally re-connect.  If we loaded from eeprom we are
 444   1         // disconnected and need to connect.  If we just renumerated this
 445   1         // is not necessary but doesn't hurt anything
 446   1         USBCS &=~bmDISCON;
 447   1      
 448   1         CKCON = (CKCON&(~bmSTRETCH)) | FW_STRETCH_VALUE; // Set stretch
 449   1      
 450   1         // clear the Sleep flag.
 451   1         Sleep = FALSE;
 452   1         GotSUD = FALSE;          // Clear SETUP flag
 453   1      
 454   1         // Task Dispatcher
 455   1         while(TRUE)               // Main Loop
 456   1         {
 457   2            // Poll User Device
 458   2            //TD_Poll();
 459   2            // Check for pending SETUP
 460   2            if(GotSUD)
 461   2            {
 462   3               SetupCommand();          // Implement setup command
 463   3               GotSUD = FALSE;          // Clear SETUP flag
 464   3            }
 465   2      
 466   2            // check for and handle suspend.
 467   2            // NOTE: Idle mode stops the processor clock.  There are only two
 468   2            // ways out of idle mode, the WAKEUP pin, and detection of the USB
 469   2            // resume state on the USB bus.  The timers will stop and the
 470   2            // processor will not wake up on any other interrupts.
 471   2            if (Sleep)
 472   2            {
 473   3               if(TD_Suspend())
 474   3               { 
 475   4                  Sleep = FALSE;     // Clear the "go to sleep" flag.  Do it here to prevent any race condition 
             -between wakeup and the next sleep.
 476   4                  do
 477   4                  {
 478   5                     EZUSB_Susp();         // Place processor in idle mode.
 479   5                  }
 480   4                  while(!Rwuen && EZUSB_EXTWAKEUP());
 481   4                  // above.  Must continue to go back into suspend if the host has disabled remote wakeup
 482   4                  // *and* the wakeup was caused by the external wakeup pin.
 483   4      
 484   4                  // 8051 activity will resume here due to USB bus or Wakeup# pin activity.
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 9   

 485   4                  EZUSB_Resume();   // If source is the Wakeup# pin, signal the host to Resume.      
 486   4                  TD_Resume();
 487   4               }   
 488   3            }
 489   2      
 490   2         }
 491   1      }
 492          
 493          BOOL HighSpeedCapable()
 494          {
 495   1         // this function determines if the chip is high-speed capable.
 496   1         // FX2 and FX2LP are high-speed capable. FX1 is not - it does
 497   1         // not have a high-speed transceiver.
 498   1      
 499   1         if (GPCR2 & bmFULLSPEEDONLY)
 500   1            return FALSE;
 501   1         else
 502   1            return TRUE;
 503   1      }   
 504          
 505          // Device request parser
 506          void SetupCommand(void)
 507          {
 508   1         void   *dscr_ptr;
 509   1         BYTE    i,length;
 510   1      
 511   1         if ((SETUPDAT[0]==UVC_SET_INTERFACE)|(SETUPDAT[0]==UVC_GET_INTERFACE)|(SETUPDAT[0]==UVC_SET_ENDPOINT)|(
             -SETUPDAT[0]==UVC_GET_ENDPOINT))
 512   1         {
 513   2         length = 0x1A;//SETUPDAT[7];
 514   2              if ((SETUPDAT[1]==GET_CUR)|(SETUPDAT[1]==GET_MIN)|(SETUPDAT[1]==GET_MAX))
 515   2              {       
 516   3                      for (i=0;i<length;i++)
 517   3                      EP0BUF[i] = valuesArray[i];
 518   3                      EP0BCH = 0;
 519   3                      EP0BCL = length;//SETUPDAT[7];  
 520   3                      
 521   3      
 522   3              }
 523   2              else if ((SETUPDAT[1]==SET_CUR)|(SETUPDAT[1]==GET_INFO))
 524   2              {
 525   3                      for (i=0;i<length;i++)
 526   3                      valuesArray[i]=EP0BUF[i];
 527   3                      
 528   3                      EP0BUF[0] = 0;
 529   3                      EP0BUF[1] = 0;
 530   3                      EP0BCH = 0;
 531   3                      EP0BCL = 2;             
 532   3              }
 533   2              else
 534   2              EZUSB_STALL_EP0();
 535   2                      // IOA = 0xFF; 
 536   2         
 537   2         }
 538   1         else
 539   1         switch(SETUPDAT[1])
 540   1         {
 541   2                
 542   2            case SC_GET_DESCRIPTOR:                  // *** Get Descriptor
 543   2               if(DR_GetDescriptor())
 544   2                  switch(SETUPDAT[3])         
 545   2                  {
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 10  

 546   3                     case GD_DEVICE:            // Device
 547   3                                 IOA = 0x00;
 548   3                        SUDPTRH = MSB(pDeviceDscr);
 549   3                        SUDPTRL = LSB(pDeviceDscr);
 550   3                        break;
 551   3                     case GD_DEVICE_QUALIFIER:            // Device Qualifier
 552   3                                        // only retuen a device qualifier if this is a high speed
 553   3                                        // capable chip.
 554   3                                        if (HighSpeedCapable())
 555   3                                        {
 556   4                                SUDPTRH = MSB(pDeviceQualDscr);
 557   4                                SUDPTRL = LSB(pDeviceQualDscr);
 558   4                                        }
 559   3                                        else
 560   3                                        {
 561   4                                                EZUSB_STALL_EP0();
 562   4                                        }
 563   3                                        break;
 564   3                     case GD_CONFIGURATION:         // Configuration
 565   3                        SUDPTRH = MSB(pConfigDscr);
 566   3                        SUDPTRL = LSB(pConfigDscr);
 567   3                        break;
 568   3                     case GD_OTHER_SPEED_CONFIGURATION:  // Other Speed Configuration
 569   3                        SUDPTRH = MSB(pOtherConfigDscr);
 570   3                        SUDPTRL = LSB(pOtherConfigDscr);
 571   3                        break;
 572   3                     case GD_STRING:            // String
 573   3                        if(dscr_ptr = (void *)EZUSB_GetStringDscr(SETUPDAT[2]))
 574   3                        {
 575   4                           SUDPTRH = MSB(dscr_ptr);
 576   4                           SUDPTRL = LSB(dscr_ptr);
 577   4                        }
 578   3                        else 
 579   3                           EZUSB_STALL_EP0();   // Stall End Point 0
 580   3                        break;
 581   3                     default:            // Invalid request
 582   3                        EZUSB_STALL_EP0();      // Stall End Point 0
 583   3                  }
 584   2               break;
 585   2            case SC_GET_INTERFACE:                  // *** Get Interface
 586   2               DR_GetInterface();
 587   2               break;
 588   2            case SC_SET_INTERFACE:                  // *** Set Interface
 589   2               DR_SetInterface();
 590   2               break;
 591   2            case SC_SET_CONFIGURATION:               // *** Set Configuration
 592   2               DR_SetConfiguration();
 593   2               break;
 594   2            case SC_GET_CONFIGURATION:               // *** Get Configuration
 595   2               DR_GetConfiguration();
 596   2               break;
 597   2            case SC_GET_STATUS:                  // *** Get Status
 598   2               if(DR_GetStatus())
 599   2                  switch(SETUPDAT[0])
 600   2                  {
 601   3                     case GS_DEVICE:            // Device
 602   3                        EP0BUF[0] = ((BYTE)Rwuen << 1) | (BYTE)Selfpwr;
 603   3                        EP0BUF[1] = 0;
 604   3                        EP0BCH = 0;
 605   3                        EP0BCL = 2;
 606   3                        break;
 607   3                     case GS_INTERFACE:         // Interface
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 11  

 608   3                        EP0BUF[0] = 0;
 609   3                        EP0BUF[1] = 0;
 610   3                        EP0BCH = 0;
 611   3                        EP0BCL = 2;
 612   3                        break;
 613   3                     case GS_ENDPOINT:         // End Point
 614   3                        EP0BUF[0] = *(BYTE xdata *) epcs(SETUPDAT[4]) & bmEPSTALL;
 615   3                        EP0BUF[1] = 0;
 616   3                        EP0BCH = 0;
 617   3                        EP0BCL = 2;
 618   3                        break;
 619   3                     default:            // Invalid Command
 620   3                        EZUSB_STALL_EP0();      // Stall End Point 0
 621   3                  }
 622   2               break;
 623   2            case SC_CLEAR_FEATURE:                  // *** Clear Feature
 624   2               if(DR_ClearFeature())
 625   2                  switch(SETUPDAT[0])
 626   2                  {
 627   3                     case FT_DEVICE:            // Device
 628   3                        if(SETUPDAT[2] == 1)
 629   3                           Rwuen = FALSE;       // Disable Remote Wakeup
 630   3                        else
 631   3                           EZUSB_STALL_EP0();   // Stall End Point 0
 632   3                        break;
 633   3                     case FT_ENDPOINT:         // End Point
 634   3                        if(SETUPDAT[2] == 0)
 635   3                        {
 636   4                           *(BYTE xdata *) epcs(SETUPDAT[4]) &= ~bmEPSTALL;
 637   4                           EZUSB_RESET_DATA_TOGGLE( SETUPDAT[4] );
 638   4                        }
 639   3                        else
 640   3                           EZUSB_STALL_EP0();   // Stall End Point 0
 641   3                        break;
 642   3                  }
 643   2               break;
 644   2            case SC_SET_FEATURE:                  // *** Set Feature
 645   2               if(DR_SetFeature())
 646   2                  switch(SETUPDAT[0])
 647   2                  {
 648   3                     case FT_DEVICE:            // Device
 649   3                        if(SETUPDAT[2] == 1)
 650   3                           Rwuen = TRUE;      // Enable Remote Wakeup
 651   3                        else if(SETUPDAT[2] == 2)
 652   3                           // Set Feature Test Mode.  The core handles this request.  However, it is
 653   3                           // necessary for the firmware to complete the handshake phase of the
 654   3                           // control transfer before the chip will enter test mode.  It is also
 655   3                           // necessary for FX2 to be physically disconnected (D+ and D-)
 656   3                           // from the host before it will enter test mode.
 657   3                           break;
 658   3                        else
 659   3                           EZUSB_STALL_EP0();   // Stall End Point 0
 660   3                        break;
 661   3                     case FT_ENDPOINT:         // End Point
 662   3                        *(BYTE xdata *) epcs(SETUPDAT[4]) |= bmEPSTALL;
 663   3                        break;
 664   3                     default:
 665   3                        EZUSB_STALL_EP0();      // Stall End Point 0
 666   3                  }
 667   2               break;
 668   2            default:                     // *** Invalid Command
 669   2               if(DR_VendorCmnd())
C51 COMPILER V7.07   FW                                                                    01/12/2013 10:12:38 PAGE 12  

 670   2                  EZUSB_STALL_EP0();            // Stall End Point 0
 671   2         }
 672   1      
 673   1         // Acknowledge handshake phase of device request
 674   1         EP0CS |= bmHSNAK;
 675   1      }
 676          
 677          // Wake-up interrupt handler
 678          void resume_isr(void) interrupt WKUP_VECT
 679          {
 680   1         EZUSB_CLEAR_RSMIRQ();
 681   1      }
 682          
 683          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1401    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     66       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
